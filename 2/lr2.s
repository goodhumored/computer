main:
  MOV R0,#0      @ Остаток R = 0
  MOV R1,#0      @ Результат Q = 0
  MOV R2,#15      @ Делимое (A)
  MOV R3,#2      @ Делитель (B)

  CMP R0, R3     @ Сравниваем R с B
  BGE overflow    @ если R < B, переходим в overflow
  
  MOV R4, #3     @ i = 3

i_loop:
  MOV R0, R0, LSL #1  @ R = (R << 1)
  MOV R5, R2      @ Кладём A в R5
  MOV R5, R5, LSR R4 @ Сдвигаем R5 вправо на i позиций
  AND R5, R5, #1  @ Получаем крайний правый бит R5

  ORR R0, R0, R5  @ R = (R << 1) | ((A >> i) & 1)

  CMP R0, #0      @ Сравниваем R с 0
  BLT plus_b      @ Если R < 0 прыгаем в plus_b

  SUBS R0, R0, R3 @ Уменьшаем R на B
  B cont

  plus_b: 
    ADDS R0, R0, R3 @ увеличиваем R на B
    B cont

cont:
  MOV R1, R1, LSL #1  @ Q = Q << 1 @ Сдвигаем Q влево на 1

  CMP R0, #0              @ Снова сравниваем R с 0
  BLT dec_i_and_check     @ Если меньше, то перепрыгиваем инкрементацию Q 
  ADDS R1, R1, #1         @ Иначе увеличиваем Q
  
dec_i_and_check:
  SUBS R4, R4, #1 @ i -= 1
  CMP R4, #0       @ Проверяем что i >= 0
  BGE i_loop        @ если да - прыгаем назад, иначе идём дальше

print_result:
  @ Успешное завершение
  MOV R0, #0      @ кладём 0 в R0
  SWI 0          @ вызываем системное прерывание для выхода с кодом 0

overflow:
  @ Переполнение - деление невозможно
  MOV R0, #1      @ кладём 0 в R0
  SWI 0          @ вызываем системное прерывание для выхода с кодом 0
